(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{411:function(_,n,e){_.exports=e.p+"assets/img/gallery-view.261b91fa.png"},418:function(_,n,e){_.exports=e.p+"assets/img/speaker-view.dd7d8b06.png"},555:function(_,n,e){"use strict";e.r(n);var t=e(6),a=Object(t.a)({},(function(){var _=this,n=_.$createElement,t=_._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("#SDK 分屏模式说明")]),_._v(" "),t("h2",{attrs:{id:"分屏模式"}},[_._v("分屏模式")]),_._v(" "),t("p",[_._v("分屏模式指的是 App 的 UI 如何为接收到的远端视频布局展示。典型分屏样式示例：主讲视图 (即一大多小布局) 和画廊视图 (平均大小布局)。当布局样式为主讲视图时，一般希望大窗口显示的视频流分辨率比较其他远端视频流更高，而当布局样式为画廊视图时，一般希望每个视频流的分辨率尽量一致。因此，在 UI 需要改变布局样式时，需要通知 SDK，这样 SDK 可以根据需要向平台发出响应请求，告知平台 UI 希望呈现的分屏布局样式，从而平台可以尽量提供满足 app 需要的视频流。")]),_._v(" "),t("p",[_._v("另外，当平台侧通过会议控制，对分屏进行改变时，SDK 也会接收到变化通知，此时 SDK 通知 UI 分屏模式发生了何种变化，UI 应该根据变化的样式进行对应的布局改变。")]),_._v(" "),t("p",[_._v("相关细节可参考 API 参考的布局类型、分屏样式请求和布局变化事件回调部分。")]),_._v(" "),t("ul",[t("li",[_._v("主讲视图 (一大多小布局) 实现示例")])]),_._v(" "),t("p",[t("img",{attrs:{src:e(418),alt:"主讲视图"}})]),_._v(" "),t("p",[_._v("主讲视图模式")]),_._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("/**\n 设置视频模式（主讲模式、画廊模式）\n\n @param layout EVLayoutRequest对象\n @return 返回结果(UI可不作处理)\n */\nint setLayout(EVLayoutRequest & layout);\n//示例代码里主讲视图模式下 主视频窗口可以显示为1x5的窗口模式\nEVLayoutRequest *layout = new EVLayoutRequest();\nlayout.page = EVLayoutCurrentPage;\n/* UI请求展示哪一页，如果是EV_LAYOUT_NEXT_PAGE，则下一次收到的onLayoutIndication是下一页可展示的窗口；如果是EV_LAYOUT_PREV_PAGE，则下一次收到的onLayoutIndication是前一页可展示的窗口。\n*/\nlayout.mode = EVLayoutSpeakerMode;\nlayout.max_type = EVLayoutType_5_4T_1B;\n\n/*可以使用在主讲模式下的类型是除画廊模式以外的类型和EV_LAYOUT_TYPE_1，此设置是最大可以使用的布局类型，服务器会根据当前入会人数，返回比枚举max_type值小的主讲模式可以选择的枚举项 */\n\nEVVideoSize vsize;\nvsize.width = 1280;\nvsize.height = 720;\nlayout.max_resolution = vsize;\nevengine->setLayout(layout);\n")])])]),t("ul",[t("li",[_._v("画廊视图 (平均大小布局) 实现示例")])]),_._v(" "),t("p",[t("img",{attrs:{src:e(411),alt:"画廊视图"}})]),_._v(" "),t("p",[_._v("画廊视图模式")]),_._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("/**\n 设置视频模式（主讲模式、画廊模式）\n\n @param layout EVLayoutRequest对象\n @return 返回结果(UI可不作处理)\n */\nint setLayout(EVLayoutRequest & layout);\n//示例代码里画廊视图模式下 主视频窗口可以显示为1x1、1x2、2x2、2x3、3x3的窗口模式（可根据需要调整窗口位置）\nEVLayoutRequest *layout = new EVLayoutRequest();\nlayout.page = EVLayoutCurrentPage;\nlayout.mode = EVLayoutGalleryMode;\nlayout.max_type = EVLayoutType_9;\n\n/*可以使用在gallery模式下的类型有EV_LAYOUT_TYPE_1，EV_LAYOUT_TYPE_2H，EV_LAYOUT_TYPE_4，EV_LAYOUT_TYPE_9，EV_LAYOUT_TYPE_16，EV_LAYOUT_TYPE_25，EV_LAYOUT_TYPE_36。这个设置是最大可以使用的类型。比如设置了EV_LAYOUT_TYPE_9，那服务器会根据当前入会人数，返回可能的类型包括EV_LAYOUT_TYPE_2H，EV_LAYOUT_TYPE_4，EV_LAYOUT_TYPE_9，也就是比枚举EV_LAYOUT_TYPE_9值小的画廊模式可以选择的枚举项 */\n\nEVVideoSize vsize;\nvsize.width = 0;\nvsize.height = 0;\nlayout.max_resolution = vsize; //用户不用设置，由SDK决定使用默认设置。\nevengine->setLayout(layout);\n")])])]),t("p",[_._v("设置分屏能力集合")]),_._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("/**\n 设置终端支持的分屏能力集，可以分别设置主讲模式和画廊模式下，所支持的分屏样式，平台会根据实际的带宽，从这个集合中，选择出合适的分屏样式发送给UI。该函数需要在终端入会前调用（建议在初始化SDK后设置一次）\n\n @param mode 主讲模式、画廊模式\n @param types 参考下面取值\n @param size types的长度\n @return 返回结果(UI可不作处理)\n */\nint setLayoutCapacity(EV_LAYOUT_MODE mode, EV_LAYOUT_TYPE types[], unsigned int size)；\n//画廊视图模式下 主视频窗口可以显示为1x1、1x2、2x2、2x3、3x3，4x4等窗口模式（可根据需要调整窗口位置）\n\n/*在画廊模式下支持的类型有EV_LAYOUT_TYPE_1，EV_LAYOUT_TYPE_2H，EV_LAYOUT_TYPE_4，EV_LAYOUT_TYPE_9，EV_LAYOUT_TYPE_16，EV_LAYOUT_TYPE_25，EV_LAYOUT_TYPE_36 */\nEVLayoutType gallery_type[] = { EVLayoutType_1, EVLayoutType_2H, EVLayoutType_4};\nEVLayoutType speaker_type[] = { EVLayoutType_1};\n\n设置画廊模式\nevengine->setLayoutCapacity(EVLayoutGalleryMode, gallery_type, 3];\n\n设置主讲模式                            \nevengine->setLayoutCapacity(EVLayoutSpeakerMode,speaker_type, 1];  \n")])])]),t("h2",{attrs:{id:"接收到分屏变化通知时应如何处理"}},[_._v("接收到分屏变化通知时应如何处理")]),_._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("void onLayoutIndication(EVLayoutIndication & layout) {\n    //当参会人数发生改变时，比如有人参会，有人离开会议；或者speaker布局下，主讲人发生改变时，会得到这个通知，此时，UI需要从新布局所有窗口。\n    //EV_LAYOUT_MODE mode; 当前应该展示的布局模式。\n    //EV_LAYOUT_MODE setting_mode;服务器当前使用的布局模式。\n    //EV_LAYOUT_TYPE type; 当前应该展示的布局具体类型。\n    //bool mode_settable;  服务器的设置，用来通知客户端是否可以改变布局模式。\n    //std::string speaker_name; 主讲人名字\n    //int speaker_index; 主讲人所在窗口的下标\n    //unsigned int sites_size; 一共有多少个可展示窗口\n   // EVSite sites[EV_LAYOUT_SIZE]; 可展示窗口的数组。\n}\n\nvoid onLayoutSiteIndication(EVSite & site) {\n    //当前展示的窗口属性发生变化时会得到这个通知，比如某个参会人名字或audio mute状态发生改变，通过device_id可以查找是哪个参会人发生了改变。UI需要更新相应的窗口状态。\n}\n\nvoid onLayoutSpeakerIndication(EVLayoutSpeakerIndication & speaker) {\n    //在gallery布局样式下，如果主讲人发生变化，会得到这个通知，客户端可以在主讲人所在的view上更新样式，比如加黄边框。speaker_index对应于最近一次收到的onLayoutIndication中的可展示窗口数组的下标。\n}   \n\n")])])]),t("h2",{attrs:{id:"布局类型"}},[_._v("布局类型")]),_._v(" "),t("p",[_._v("用于设置布局类型请求，通常仅需要典型画廊视图或主讲视图样式。当需要画廊视图时，应选择 nxn 的类型，而需要主讲视图时应选择 1+n 的类型。假设 app 设计的最大接收视频数为 16 ，那么画廊视图时设置为 4x4 (EV_LAYOUT_TYPE_16) 布局，而对主讲视图设置为 1+16 (EV_LAYOUT_TYPE_1TLP16) 布局即可。平台会根据 SDK 的布局设置，尽可能提供适合的视频流。")]),_._v(" "),t("div",{staticClass:"language-C++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("typedef enum _EV_LAYOUT_TYPE{\n    EV_LAYOUT_TYPE_AUTO       = -1,\n    EV_LAYOUT_TYPE_1          = 101,\t\t// 1x1\n    EV_LAYOUT_TYPE_2H         = 201,\t\t// 1x2\n    EV_LAYOUT_TYPE_2V         = 202,\t\t// 2x1\n    EV_LAYOUT_TYPE_2H_2       = 203,\t\t// \n    EV_LAYOUT_TYPE_2V_2       = 204,\n    EV_LAYOUT_TYPE_2_1IN1     = 205,\n    EV_LAYOUT_TYPE_2_1L_1RS   = 207,\n    EV_LAYOUT_TYPE_3_1T_2B    = 301,\t\t\n    EV_LAYOUT_TYPE_3_2T_1B    = 302,\n    EV_LAYOUT_TYPE_3_1L_2R    = 303,\n    EV_LAYOUT_TYPE_3_2IN1     = 304,\n    EV_LAYOUT_TYPE_1P2W       = 305,\n    EV_LAYOUT_TYPE_4          = 401,\t\t// 2x2\n    EV_LAYOUT_TYPE_4_3T_1B    = 402,\n    EV_LAYOUT_TYPE_4_1L_3R    = 403,\n    EV_LAYOUT_TYPE_4_1T_3B    = 404,\n    EV_LAYOUT_TYPE_4_3IN1     = 405,\n    EV_LAYOUT_TYPE_5_1L_4R    = 501,\n    EV_LAYOUT_TYPE_5_4T_1B    = 502,\n    EV_LAYOUT_TYPE_5_1T_4B    = 503,\n    EV_LAYOUT_TYPE_6          = 601,\t\t// 1+5\n    EV_LAYOUT_TYPE_6W         = 602,\n    EV_LAYOUT_TYPE_2P4W       = 603,\n    EV_LAYOUT_TYPE_6CP        = 604,\n    EV_LAYOUT_TYPE_8          = 801,\t\t// 1+7\n    EV_LAYOUT_TYPE_9          = 901,\t\t// 3x3\n    EV_LAYOUT_TYPE_9_1IN_8OUT = 902,\t\t// 1+8\n    EV_LAYOUT_TYPE_9_8T_1B    = 903,\t\t// 1+8\n    EV_LAYOUT_TYPE_9_1T_8B    = 904,\t\t// 1+8\n    EV_LAYOUT_TYPE_10         = 1001,\t\t// 2+8\n    EV_LAYOUT_TYPE_2TP8B      = 1002,\t\t// 2+8\n    EV_LAYOUT_TYPE_2CP4L4R    = 1003,\n    EV_LAYOUT_TYPE_12W        = 1201,\n    EV_LAYOUT_TYPE_13         = 1301,\n    EV_LAYOUT_TYPE_1LTP12     = 1302,\n    EV_LAYOUT_TYPE_16         = 1601,\t\t// 4x4\n\t\t...... \n    EV_LAYOUT_TYPE_1TLP16     = 1701,\t\t// 1+16\n\t\t......\n\n} EV_LAYOUT_TYPE;  \n")])])]),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("typedef enum _EV_LAYOUT_MODE{\n    EV_LAYOUT_AUTO_MODE =  0,\n    EV_LAYOUT_GALLERY_MODE =  1,\n    EV_LAYOUT_SPEAKER_MODE =  2,\n    EV_LAYOUT_SPECIFIED_MODE =  3\n} EV_LAYOUT_MODE;\n")])])]),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("typedef enum _EV_LAYOUT_PAGE{\n    EV_LAYOUT_CURRENT_PAGE = 0,\n    EV_LAYOUT_PREV_PAGE = 1,\n    EV_LAYOUT_NEXT_PAGE = 2\n} EV_LAYOUT_PAGE;\n")])])]),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("class EV_CLASS_API EVLayoutRequest {\npublic:\n    EVLayoutRequest() {\n        clear();\n    }\n    void clear() {\n        mode = EV_LAYOUT_AUTO_MODE;\n        max_type = EV_LAYOUT_TYPE_AUTO;\n        page = EV_LAYOUT_CURRENT_PAGE;\n        max_resolution.width = max_resolution.height = 0;\n        windows_size = 0;\n        memset(windows, 0, sizeof(windows));\n    }\n    EV_LAYOUT_MODE mode;\n    EV_LAYOUT_TYPE max_type;\n    EV_LAYOUT_PAGE page;\n    EVVideoSize max_resolution;\n    unsigned int windows_size;\n    void * windows[EV_LAYOUT_SIZE];\n};\n\n")])])]),t("h2",{attrs:{id:"布局更新消息"}},[_._v("布局更新消息")]),_._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v('class EV_CLASS_API EVLayoutIndication {\npublic:\n    EVLayoutIndication() {\n        clear();\n    }\n    void clear() {\n        mode = EV_LAYOUT_AUTO_MODE;\n        setting_mode = EV_LAYOUT_AUTO_MODE;\n        type = EV_LAYOUT_TYPE_1;\n        mode_settable = TRUE;\n        speaker_name = "";\n        speaker_index = -1;\n        sites_size = 0;\n        int i;\n        for(i = 0; i < EV_LAYOUT_SIZE; i++) {\n            sites[i].clear();\n        }\n    }\n    EV_LAYOUT_MODE mode;\n    EV_LAYOUT_MODE setting_mode;\n    EV_LAYOUT_TYPE type;\n    bool mode_settable;\n    std::string speaker_name;\n    int speaker_index;\n    unsigned int sites_size;\n    EVSite sites[EV_LAYOUT_SIZE];\n};\n\n')])])]),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v('class EV_CLASS_API EVSite {\npublic:\n    EVSite() {\n        clear();\n    }\n    void clear() {\n        window = NULL;\n        is_local = TRUE;\n        name = "";\n        device_id = 0;\n        mic_muted = FALSE;\n        remote_muted = FALSE;\n    }\n    void * window;\n    bool is_local;\n    std::string name;\n    uint64_t device_id;\n    bool mic_muted;\n    bool remote_muted;\n};\n\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);